/**
 * OBO Ontology Parser
 * Parses OBO format files used for ontologies.
 */

export class TermStanza {
  // Required tags
  id!: string;
  // Optional tags
  name?: string;
  definition?: string;
  private parents: Set<TermStanza> = new Set();
  private children: Set<TermStanza> = new Set();

  constructor() {}

  addParent(parent: TermStanza): void {
    this.parents.add(parent);
  }

  addChild(child: TermStanza): void {
    this.children.add(child);
  }

  removeParent(parent: TermStanza): boolean {
    return this.parents.delete(parent);
  }

  removeChild(child: TermStanza): boolean {
    return this.children.delete(child);
  }

  getParents(): TermStanza[] {
    return Array.from(this.parents);
  }

  getChildren(): TermStanza[] {
    return Array.from(this.children);
  }

  hasParents(): boolean {
    return this.parents.size > 0;
  }

  hasChildren(): boolean {
    return this.children.size > 0;
  }

  isValid(): boolean {
    return this.id !== undefined;
  }
}

export class Ontology {
  // Required header tags
  private formatVersion!: string;
  // Optional header tags
  private dataVersion?: string;
  private date?: Date;
  private savedBy?: string;
  private autoGeneratedBy?: string;
  private import?: string;
  private subsetdef?: string;
  private synonymtypedef?: string;
  private defaultNamespace?: string;
  private namespaceIdRule?: string;
  private idspace?: string;
  private treatXrefsAsEquivalent?: string;
  private treatXrefsAsGenusDifferentia?: string;
  private treatXrefsAsRelationship?: string;
  private treatXrefsAsIsA?: string;
  private remark?: string;
  private ontology?: string;
  // Ontology terms
  private stanzas: TermStanza[] = [];

  constructor(obo?: string) {
    if (obo) {
      this.parseObo(obo);
    } else {
      this.formatVersion = '1.2';
    }
  }

  getAllOntologyTerms(): TermStanza[] {
    return this.stanzas;
  }

  getRootTerms(): TermStanza[] {
    return this.stanzas.filter((term) => !term.hasParents());
  }

  findTermById(id: string): TermStanza | undefined {
    return this.stanzas.find((term) => term.id === id);
  }

  addTerm(term: TermStanza): void {
    if (term.isValid()) {
      this.stanzas.push(term);
    }
  }

  removeTerm(term: TermStanza): void {
    const index = this.stanzas.indexOf(term);
    if (index !== -1) {
      this.stanzas.splice(index, 1);
    }
    if (term.hasChildren()) {
      term.getChildren().forEach((t) => {
        if (t.getParents().length === 1) {
          this.removeTerm(t);
        } else {
          t.removeParent(term);
        }
      });
    }
    if (term.hasParents()) {
      term.getParents().forEach((t) => {
        t.removeChild(term);
      });
    }
  }

  createTerm(id: string, name?: string, definition?: string, parentId?: string): TermStanza {
    const term = new TermStanza();
    term.id = id;
    term.name = name;
    term.definition = definition;
    
    if (parentId) {
      const parent = this.findTermById(parentId);
      if (parent) {
        term.addParent(parent);
        parent.addChild(term);
      }
    }
    
    this.addTerm(term);
    return term;
  }

  moveTerm(termId: string, newParentId: string | null): boolean {
    const term = this.findTermById(termId);
    if (!term) return false;

    if (newParentId === termId) return false;

    const newParent = newParentId ? this.findTermById(newParentId) : null;
    if (newParent && this.isDescendant(term, newParent)) {
      return false;
    }

    const currentParents = term.getParents();
    currentParents.forEach((parent) => {
      parent.removeChild(term);
      term.removeParent(parent);
    });

    if (newParent) {
      term.addParent(newParent);
      newParent.addChild(term);
    }

    return true;
  }

  /**
   * Generate next available DIO ID
   */
  getNextId(): string {
    let maxId = 0;
    for (const term of this.stanzas) {
      const match = term.id.match(/DIO:(\d+)/);
      if (match) {
        const num = parseInt(match[1], 10);
        if (num > maxId) {
          maxId = num;
        }
      }
    }
    return `DIO:${String(maxId + 1).padStart(7, '0')}`;
  }

  private parseObo(obo: string): void {
    const lines = obo.split('\n');
    this.parseHeader(lines);
    this.parseStanza(lines);
  }

  private parseHeader(lines: string[]): void {
    const headerProperties: {
      [key: string]: { setter: (value: string) => void };
    } = {
      formatVersion: {
        setter: (value: string) => (this.formatVersion = value),
      },
      dataVersion: {
        setter: (value: string) => (this.dataVersion = value),
      },
      date: {
        setter: (value: string) => {
          const [day, month, year, hours, minutes] = value.split(/[:\s]/);
          const parsedDate = new Date(+year, +month - 1, +day, +hours, +minutes);
          this.date = parsedDate;
        },
      },
      savedBy: {
        setter: (value: string) => (this.savedBy = value),
      },
      autoGeneratedBy: {
        setter: (value: string) => (this.autoGeneratedBy = value),
      },
      ontology: {
        setter: (value: string) => (this.ontology = value),
      },
    };
    const stanzaRegex = /^\[(\w+)\]/;

    let line;
    while ((line = lines.shift()) !== undefined) {
      let matched = false;
      const [tag, value] = line.split(/: /);
      if (tag !== undefined && value !== undefined) {
        const camelCaseTag = this.kebabToCamel(tag);
        if (headerProperties[camelCaseTag] !== undefined) {
          headerProperties[camelCaseTag].setter(value.trim());
          matched = true;
        }
      }

      if (!matched && stanzaRegex.test(line)) {
        lines.unshift(line);
        return;
      }
    }
  }

  private parseStanza(lines: string[]): void {
    const stanzaRegex = /^\[(\w+)\]/;
    const unresolvedLinks: { childId: string; parentId: string }[] = [];
    
    let ontologyTerm: TermStanza = new TermStanza();
    
    const termProperties: {
      [key: string]: { setter: (value: string) => void };
    } = {
      id: {
        setter: (value: string) => (ontologyTerm.id = value),
      },
      name: {
        setter: (value: string) => (ontologyTerm.name = value),
      },
      def: {
        setter: (value: string) => {
          ontologyTerm.definition = value.replace(/"/g, '');
        },
      },
      is_a: {
        setter: (parentID: string) => {
          unresolvedLinks.push({ childId: ontologyTerm.id, parentId: parentID });
        },
      },
    };

    let line;
    while ((line = lines.shift()) !== undefined) {
      let matched = false;
      const [tag, value] = line.split(/: | ! /);
      if (tag !== undefined && value !== undefined) {
        if (termProperties[tag] !== undefined) {
          termProperties[tag].setter(value.trim());
          matched = true;
        }
      }

      if (!matched && stanzaRegex.test(line)) {
        this.addTerm(ontologyTerm);
        ontologyTerm = new TermStanza();
      }
    }
    this.addTerm(ontologyTerm);

    // Resolve parent-child relationships
    unresolvedLinks.forEach(({ childId, parentId }) => {
      const child = this.findTermById(childId);
      const parent = this.findTermById(parentId);
      if (child && parent) {
        parent.addChild(child);
        child.addParent(parent);
      }
    });
  }

  private isDescendant(term: TermStanza, candidate: TermStanza): boolean {
    const stack: TermStanza[] = [...term.getChildren()];
    while (stack.length > 0) {
      const current = stack.pop();
      if (!current) continue;
      if (current === candidate) return true;
      stack.push(...current.getChildren());
    }
    return false;
  }

  private kebabToCamel(s: string): string {
    return s.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  }

  toString(): string {
    const oboString: string[] = [];

    // Header
    oboString.push(`format-version: ${this.formatVersion}`);
    if (this.dataVersion) oboString.push(`data-version: ${this.dataVersion}`);
    if (this.date) oboString.push(`date: ${this.date}`);
    if (this.savedBy) oboString.push(`saved-by: ${this.savedBy}`);
    if (this.autoGeneratedBy) oboString.push(`auto-generated-by: ${this.autoGeneratedBy}`);
    if (this.import) oboString.push(`import: ${this.import}`);
    if (this.subsetdef) oboString.push(`subsetdef: ${this.subsetdef}`);
    if (this.synonymtypedef) oboString.push(`synonymtypedef: ${this.synonymtypedef}`);
    if (this.defaultNamespace) oboString.push(`default-namespace: ${this.defaultNamespace}`);
    if (this.namespaceIdRule) oboString.push(`namespace-id-rule: ${this.namespaceIdRule}`);
    if (this.idspace) oboString.push(`idspace: ${this.idspace}`);
    if (this.treatXrefsAsEquivalent) oboString.push(`treat-xrefs-as-equivalent: ${this.treatXrefsAsEquivalent}`);
    if (this.treatXrefsAsGenusDifferentia) oboString.push(`treat-xrefs-as-genus-differentia: ${this.treatXrefsAsGenusDifferentia}`);
    if (this.treatXrefsAsRelationship) oboString.push(`treat-xrefs-as-relationship: ${this.treatXrefsAsRelationship}`);
    if (this.treatXrefsAsIsA) oboString.push(`treat-xrefs-as-is_a: ${this.treatXrefsAsIsA}`);
    if (this.remark) oboString.push(`remark: ${this.remark}`);
    if (this.ontology) oboString.push(`ontology: ${this.ontology}`);
    oboString.push('');

    // Term Stanzas - sorted by ID
    const sortedStanzas = [...this.stanzas].sort((a, b) => a.id.localeCompare(b.id));
    sortedStanzas.forEach((term) => {
      oboString.push('[Term]');
      oboString.push(`id: ${term.id}`);
      if (term.name) oboString.push(`name: ${term.name}`);
      if (term.definition) oboString.push(`def: "${term.definition}"`);
      term.getParents().forEach((parent) => {
        oboString.push(`is_a: ${parent.id}`);
      });
      oboString.push('');
    });
    return oboString.join('\n');
  }

  toOBOFile(): File {
    return new File([this.toString()], 'dio.obo', { type: 'text/plain' });
  }
}
