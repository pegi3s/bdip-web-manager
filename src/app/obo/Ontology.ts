import { TermStanza } from './TermStanza';

export class Ontology {
  // Required header tags
  private formatVersion!: string;
  // Optional header tags
  private dataVersion?: string;
  private date?: Date;
  private savedBy?: string;
  private autoGeneratedBy?: string;
  private import?: string;
  private subsetdef?: string;
  private synonymtypedef?: string;
  private defaultNamespace?: string;
  private namespaceIdRule?: string;
  private idspace?: string;
  private treatXrefsAsEquivalent?: string;
  private treatXrefsAsGenusDifferentia?: string;
  private treatXrefsAsRelationship?: string;
  private treatXrefsAsIsA?: string;
  private remark?: string;
  private ontology?: string;
  // Ontology terms
  private stanzas: TermStanza[] = [];

  constructor(obo: string) {
    this.parseObo(obo);
  }

  public getAllOntologyTerms() {
    return this.stanzas;
  }

  public getRootTerms() {
    return this.stanzas.filter((term) => term.hasParents() === false);
  }

  private addTerm(term: TermStanza) {
    if (term.isValid())
      this.stanzas.push(term);
  }

  public removeTerm(term: TermStanza): void {
    const index = this.stanzas.indexOf(term);
    if (index !== -1) {
      this.stanzas.splice(index, 1);
    }
    if (term.hasChildren()) {
      term.getChildren().forEach((t) => {
        if (t.getParents().length === 1) {
          this.removeTerm(t);
        } else {
          t.removeParent(term);
        }
      });
    }
    if (term.hasParents()) {
      term.getParents().forEach((t) => {
        t.removeChild(term);
      });
    }
  }

  /**
   * Parse an OBO file provided as a string.
   */
  private parseObo(obo: string) {
    const lines = obo.split('\n');
    this.parseHeader(lines);
    this.parseStanza(lines);
  }

  private parseHeader(lines: string[]) {
    const headerProperties: {
      [key: string]: { setter: (value: string) => void };
    } = {
      formatVersion: {
        setter: (value: string) => (this.formatVersion = value),
      },
      dataVersion: {
        setter: (value: string) => (this.dataVersion = value),
      },
      date: {
        setter: (value: string) => {
          const [day, month, year, hours, minutes] = value.split(/[:\s]/);
          const parsedDate = new Date(
            +year,
            +month - 1,
            +day,
            +hours,
            +minutes,
          );
          this.date = parsedDate;
        },
      },
      savedBy: {
        setter: (value: string) => (this.savedBy = value),
      },
      autoGeneratedBy: {
        setter: (value: string) => (this.autoGeneratedBy = value),
      },
      // import
      // subsetdef
      // synonymtypedef
      // default-namespace
      // namespace-id-rule
      // idspace
      // treat-xrefs-as-equivalent
      // treat-xrefs-as-genus-differentia
      // treat-xrefs-as-relationship
      // treat-xrefs-as-is_a
      // remark
      ontology: {
        setter: (value: string) => (this.ontology = value),
      },
    };
    const stanzaRegex = /^\[(\w+)\]/;

    let line;
    while ((line = lines.shift()) !== undefined) {
      let matched = false;
      const [tag, value, comment] = line.split(/: | ! /);
      if (tag !== undefined && value !== undefined) {
        const camelCaseTag = this.kebabToCamel(tag);
        if (headerProperties[camelCaseTag] === undefined) {
          console.warn(`Unknown tag: ${tag}`);
        } else {
          headerProperties[camelCaseTag].setter(value.trim());
          matched = true;
        }
      }

      if (!matched && stanzaRegex.test(line)) {
        // The header ends when the first stanza is encountered.
        lines.unshift(line);
        return;
      }
    }
  }

  // [Term], [Typedef], and [Instance] stanzas should be serialized in alphabetical order on the value of their id tag.
  private parseStanza(lines: string[]) {
    // Regular expression to match stanza headers
    const stanzaRegex = /^\[(\w+)\]/;
    // Object mapping term properties to their setter functions
    const termProperties: {
      [key: string]: { setter: (value: string) => void };
    } = {
      id: {
        setter: (value: string) => (ontologyTerm.id = value),
      },
      name: {
        setter: (value: string) => (ontologyTerm.name = value),
      },
      def: {
        setter: (value: string) => {ontologyTerm.definition = value.replace(/"/g, '')},
      },
      is_a: {
        setter: (parentID: string) => {
          const parent = this.stanzas.find((term) => term.id === parentID);
          if (parent) {
            parent.addChild(ontologyTerm);
            ontologyTerm.addParent(parent);
          }
        },
      },
    };

    let ontologyTerm: TermStanza = new TermStanza();
    let line;
    while ((line = lines.shift()) !== undefined) {
      let matched = false;
      // Split the line into tag, value, and comment
      const [tag, value, comment] = line.split(/: | ! /);
      if (tag !== undefined && value !== undefined) {
        // If the tag is not recognized, log a warning
        if (termProperties[tag] === undefined) {
          console.warn(`Unknown tag: ${tag}`);
        } else {
          termProperties[tag].setter(value.trim());
          matched = true;
        }
      }

      // If the line did not match any tag and that line indicates a new stanza,
      // add the current term to the ontology
      if (!matched && stanzaRegex.test(line)) {
        this.addTerm(ontologyTerm);
        ontologyTerm = new TermStanza();
      }
    }
    // Add the last term to the ontology
    this.addTerm(ontologyTerm);
  }

  private kebabToCamel(s: string): string {
    return s.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  }

  public toString(): string {
    const oboString: string[] = [];

    // Header
    oboString.push(`format-version: ${this.formatVersion}`);
    if (this.dataVersion) oboString.push(`data-version: ${this.dataVersion}`);
    if (this.date) oboString.push(`date: ${this.date}`);
    if (this.savedBy) oboString.push(`saved-by: ${this.savedBy}`);
    if (this.autoGeneratedBy)
      oboString.push(`auto-generated-by: ${this.autoGeneratedBy}`);
    if (this.import) oboString.push(`import: ${this.import}`);
    if (this.subsetdef) oboString.push(`subsetdef: ${this.subsetdef}`);
    if (this.synonymtypedef)
      oboString.push(`synonymtypedef: ${this.synonymtypedef}`);
    if (this.defaultNamespace)
      oboString.push(`default-namespace: ${this.defaultNamespace}`);
    if (this.namespaceIdRule)
      oboString.push(`namespace-id-rule: ${this.namespaceIdRule}`);
    if (this.idspace) oboString.push(`idspace: ${this.idspace}`);
    if (this.treatXrefsAsEquivalent)
      oboString.push(
        `treat-xrefs-as-equivalent: ${this.treatXrefsAsEquivalent}`,
      );
    if (this.treatXrefsAsGenusDifferentia)
      oboString.push(
        `treat-xrefs-as-genus-differentia: ${this.treatXrefsAsGenusDifferentia}`,
      );
    if (this.treatXrefsAsRelationship)
      oboString.push(
        `treat-xrefs-as-relationship: ${this.treatXrefsAsRelationship}`,
      );
    if (this.treatXrefsAsIsA)
      oboString.push(`treat-xrefs-as-is_a: ${this.treatXrefsAsIsA}`);
    if (this.remark) oboString.push(`remark: ${this.remark}`);
    if (this.ontology) oboString.push(`ontology: ${this.ontology}`);
    oboString.push(``);

    // Term Stanzas
    this.stanzas.forEach((term) => {
      oboString.push(`[Term]`);
      oboString.push(`id: ${term.id}`);
      if (term.name) oboString.push(`name: ${term.name}`);
      if (term.definition) oboString.push(`def: "${term.definition}"`);
      term.getParents().forEach((parent) => {
        oboString.push(`is_a: ${parent.id}`);
      });
      oboString.push(``);
    });
    return oboString.join('\n');
  }

  public toOBOFile() {
    return new File([this.toString()], 'dio.obo', { type: 'text/plain' });
  }
}
